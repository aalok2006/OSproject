<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Hybrid Virtual Memory Manager</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;700&family=Fira+Code:wght@400&display=swap');

        :root {
            --bg-color: #161b22; /* GitHub Dark Dimmed BG */
            --surface-color: rgba(34, 40, 49, 0.6); /* Slightly transparent surface */
            --surface-solid-color: #222831;
            --text-color: #c9d1d9; /* GitHub Dark Dimmed Text */
            --text-muted-color: #8b949e;
            --primary-color: #58a6ff; /* GitHub Blue */
            --secondary-color: #a371f7; /* GitHub Purple */
            --success-color: #3fb950; /* GitHub Green */
            --warning-color: #d29922; /* GitHub Yellow */
            --error-color: #f85149; /* GitHub Red */
            --dirty-color: #f85149; /* Red for dirty */
            --highlight-color: #fada5e; /* Brighter yellow */

            --ram-color-start: #64b5f6; /* Light Blue */
            --ram-color-end: #1976d2;   /* Darker Blue */
            --swap-color-start: #ffab91; /* Light Orange/Red */
            --swap-color-end: #d84315;   /* Deep Orange */
            --cache-color-start: #a5d6a7; /* Light Green */
            --cache-color-end: #2e7d32;   /* Darker Green */

            --border-radius: 12px;
            --box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            --box-shadow-inset: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            --border-color-light: #30363d;
            --backdrop-blur: 8px;

            --font-main: 'Poppins', sans-serif;
            --font-mono: 'Fira Code', monospace;

            --transition-speed-fast: 0.2s;
            --transition-speed-medium: 0.4s;
            --transition-speed-slow: 0.7s;
            --move-animation-speed: 1s; /* Specific for block moves */
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-main);
            text-align: center;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%2320252c' fill-opacity='0.4'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"), var(--bg-color);
            color: var(--text-color);
            padding: 25px 10px;
            line-height: 1.7;
            overflow-x: hidden;
        }

        .main-container {
            max-width: 1400px;
            margin: 15px auto;
            padding: 0 20px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 30px;
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(88, 166, 255, 0.3);
            animation: fadeInDown 0.8s ease-out;
        }

        /* Glassmorphism Panel Style */
        .panel {
            background: var(--surface-color);
            padding: 20px 25px;
            margin-bottom: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color-light);
            backdrop-filter: blur(var(--backdrop-blur));
            -webkit-backdrop-filter: blur(var(--backdrop-blur));
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            animation: fadeInUp 0.6s ease-out forwards;
            opacity: 0; /* Start hidden for animation */
        }
        .panel:nth-of-type(2) { animation-delay: 0.1s; }
        .panel:nth-of-type(3) { animation-delay: 0.2s; }

        .panel label, .panel span {
            margin-right: 8px;
            font-weight: 500;
            font-size: 0.95em;
            color: var(--text-muted-color);
        }
        .panel strong {
            color: var(--primary-color);
            font-weight: 600;
        }

        .stats-container {
            font-size: 0.9em;
            justify-content: space-around;
            padding: 15px 20px;
        }
        .stats-container span { margin: 0 12px; white-space: nowrap; }
        .stats-container strong { font-size: 1.1em; margin-left: 4px; }

        #thrashing-indicator {
            color: var(--error-color);
            font-weight: bold;
            margin-left: 20px;
            display: none; /* Hidden by default */
            animation: thrashingPulse 1s infinite;
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 40px;
            margin-top: 35px;
            position: relative; /* For moving block positioning */
            animation: fadeInUp 0.8s 0.3s ease-out forwards;
            opacity: 0;
        }

        .memory-section {
            min-height: 350px;
            background: var(--surface-color);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color-light);
            backdrop-filter: blur(var(--backdrop-blur));
            -webkit-backdrop-filter: blur(var(--backdrop-blur));
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow: hidden; /* Clip moving blocks */
        }

        .memory-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 12px;
            width: 100%;
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            text-shadow: 0 0 5px rgba(88, 166, 255, 0.2);
        }

         .memory-usage-container {
            width: 100%;
            margin-bottom: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
         }
         .memory-usage-text {
            font-size: 0.9em;
            color: var(--text-muted-color);
            font-weight: 500;
            white-space: nowrap;
         }
        .progress-bar-container {
            flex-grow: 1;
            height: 8px;
            background-color: #30363d;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            width: 0%; /* Updated by JS */
            border-radius: 4px;
            transition: width var(--transition-speed-medium) ease-out;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
        }

        .block-container {
            width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
            padding-top: 5px; /* Space for hover effect */
        }

        .block {
            width: calc(100% - 4px);
            height: 42px;
            text-align: center;
            line-height: 42px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition:
                background var(--transition-speed-medium) ease,
                transform var(--transition-speed-fast) ease,
                box-shadow var(--transition-speed-medium) ease,
                opacity var(--transition-speed-medium) ease,
                border var(--transition-speed-fast) ease;
            position: relative;
            border: 2px solid transparent;
            color: #ffffff;
            font-size: 0.95em;
            overflow: hidden;
            z-index: 1;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            box-shadow: var(--box-shadow-inset), 0 2px 4px rgba(0,0,0,0.2);
        }

        .block::before { /* Gradient overlay */
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 100%);
            border-radius: inherit;
            opacity: 0.8;
            transition: opacity var(--transition-speed-medium) ease;
            z-index: -1;
            pointer-events: none;
        }

         .block:hover {
             transform: translateY(-3px) scale(1.03);
             border-color: var(--highlight-color);
             box-shadow: 0 6px 15px rgba(250, 218, 94, 0.3), var(--box-shadow-inset);
             z-index: 10; /* Bring to front on hover */
         }
         .block:hover::before { opacity: 1; }

        .in-ram { background: linear-gradient(60deg, var(--ram-color-start), var(--ram-color-end)); }
        .in-swap { background: linear-gradient(60deg, var(--swap-color-start), var(--swap-color-end)); }
        .in-cache { background: linear-gradient(60deg, var(--cache-color-start), var(--cache-color-end)); }

        /* Dirty block styling */
        .block-dirty {
            border-left: 5px solid var(--dirty-color);
            animation: dirtyPulse 1.5s infinite ease-in-out;
        }
        .block-dirty::after { /* Small indicator icon concept */
            content: '‚óè';
            position: absolute;
            top: 4px;
            right: 8px;
            color: var(--dirty-color);
            font-size: 1.2em;
            line-height: 1;
            text-shadow: 0 0 3px black;
        }


        /* --- Animation Classes --- */
        .block-highlight { animation: highlight-pulse calc(var(--transition-speed-slow) * var(--sim-speed-factor, 1)) 1 ease-in-out; }
        .block-fade-out { animation: fade-out calc(var(--transition-speed-medium) * var(--sim-speed-factor, 1)) forwards ease-out; }
        .block-fade-in { animation: fade-in calc(var(--transition-speed-medium) * var(--sim-speed-factor, 1)) forwards ease-in; }
        .block-terminate { animation: terminate-effect calc(var(--transition-speed-medium) * 1.2 * var(--sim-speed-factor, 1)) forwards ease-in; }
        .block-write-back { animation: write-back-pulse calc(var(--transition-speed-slow) * var(--sim-speed-factor, 1)) 1 ease-in-out; }
        .block-marked-dirty { animation: marked-dirty-pulse 0.5s 1 ease-out; }

        /* Moving Block Styling */
        .block-moving {
            position: fixed; /* Use fixed for viewport positioning */
            z-index: 1000;
            pointer-events: none;
            transition:
                top calc(var(--move-animation-speed) * var(--sim-speed-factor, 1)) cubic-bezier(0.68, -0.55, 0.27, 1.55), /* Ease with overshoot */
                left calc(var(--move-animation-speed) * var(--sim-speed-factor, 1)) cubic-bezier(0.68, -0.55, 0.27, 1.55),
                transform calc(var(--move-animation-speed) * var(--sim-speed-factor, 1)) ease-in-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            transform: scale(1.1) rotate(3deg); /* Slightly larger and rotated when moving */
            filter: brightness(1.1);
        }

        /* Keyframes */
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes highlight-pulse {
            0%, 100% { box-shadow: 0 0 8px 4px var(--highlight-color), var(--box-shadow-inset); border-color: var(--highlight-color); filter: brightness(1.1); }
            50% { box-shadow: 0 0 20px 10px var(--highlight-color), var(--box-shadow-inset); border-color: var(--highlight-color); filter: brightness(1.3); }
        }
        @keyframes fade-out { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.8); } }
        @keyframes fade-in { from { opacity: 0; transform: scale(0.8) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        @keyframes terminate-effect {
            0% { opacity: 1; transform: scale(1) rotate(0deg); }
            100% { opacity: 0; transform: scale(0) rotate(360deg); height: 0; margin: 0; padding: 0; border: 0; }
        }
        @keyframes write-back-pulse {
            0%, 100% { box-shadow: 0 0 8px 4px var(--secondary-color), var(--box-shadow-inset); filter: brightness(1.0); }
            50% { box-shadow: 0 0 20px 10px var(--secondary-color), var(--box-shadow-inset); filter: brightness(1.2); }
        }
        @keyframes marked-dirty-pulse {
             0%, 100% { border-left-color: var(--dirty-color); }
             50% { border-left-color: #ff8a80; /* Lighter red */ }
        }
        @keyframes dirtyPulse {
             0%, 100% { border-left-width: 5px; }
             50% { border-left-width: 7px; }
        }
         @keyframes thrashingPulse {
             0%, 100% { opacity: 1; transform: scale(1); }
             50% { opacity: 0.7; transform: scale(1.05); }
         }


        /* Controls Styling */
        button, select, input[type="number"], input[type="text"] {
            margin: 5px 6px;
            padding: 10px 18px;
            background: rgba(58, 62, 68, 0.8); /* Darker, slightly transparent */
            color: var(--text-color);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all var(--transition-speed-fast) ease;
            font-family: var(--font-main);
            box-shadow: var(--box-shadow-inset);
            backdrop-filter: blur(2px); /* Subtle blur on controls */
            -webkit-backdrop-filter: blur(2px);
        }
        input[type="number"], input[type="text"] {
            width: 75px;
            cursor: text;
            text-align: center;
        }
         input[type="text"]#processIdInput { width: 120px; }

         input:focus, select:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 10px rgba(88, 166, 255, 0.4), var(--box-shadow-inset);
             background-color: rgba(70, 75, 82, 0.9);
         }
        button {
             background-color: var(--primary-color);
             color: #111;
             font-weight: 500;
             border: none;
             box-shadow: 0 3px 8px rgba(88, 166, 255, 0.3);
             display: inline-flex;
             align-items: center;
             gap: 6px;
        }
        button:hover {
            background-color: #79b8ff; /* Lighter blue */
            box-shadow: 0 5px 12px rgba(88, 166, 255, 0.4);
            transform: translateY(-2px);
        }
        button:active {
            background-color: #4698f7;
            transform: translateY(0px);
            box-shadow: 0 1px 4px rgba(88, 166, 255, 0.2);
        }
        button .icon { font-size: 1.1em; } /* Style for text icons */

        /* Secondary Button Style (Purple) */
        button.secondary { background-color: var(--secondary-color); box-shadow: 0 3px 8px rgba(163, 113, 247, 0.3); }
        button.secondary:hover { background-color: #b392f9; box-shadow: 0 5px 12px rgba(163, 113, 247, 0.4); }
        button.secondary:active { background-color: #9a5deb; box-shadow: 0 1px 4px rgba(163, 113, 247, 0.2); }

         /* Danger Button Style (Red) */
         button.danger { background-color: var(--error-color); box-shadow: 0 3px 8px rgba(248, 81, 73, 0.3); }
         button.danger:hover { background-color: #ff7b72; box-shadow: 0 5px 12px rgba(248, 81, 73, 0.4); }
         button.danger:active { background-color: #e1463f; box-shadow: 0 1px 4px rgba(248, 81, 73, 0.2); }


        /* Log Styling */
        #log-container {
            margin: 40px auto;
            padding: 25px;
            background: var(--surface-color);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color-light);
            backdrop-filter: blur(var(--backdrop-blur));
            -webkit-backdrop-filter: blur(var(--backdrop-blur));
            max-width: 95%;
            box-shadow: var(--box-shadow);
             animation: fadeInUp 1s 0.5s ease-out forwards;
             opacity: 0;
        }
        #log {
            height: 300px;
            overflow-y: auto;
            text-align: left;
            font-family: var(--font-mono);
            font-size: 0.9em;
            position: relative;
        }
         /* Custom Scrollbar */
        #log::-webkit-scrollbar { width: 8px; }
        #log::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        #log::-webkit-scrollbar-thumb { background: var(--primary-color); border-radius: 4px; }
        #log::-webkit-scrollbar-thumb:hover { background: #79b8ff; }

        #log .log-title {
             color: var(--primary-color);
             display: block;
             margin-bottom: 15px;
             font-size: 1.2em;
             font-family: var(--font-main);
             font-weight: 600;
             border-bottom: 1px solid var(--border-color-light);
             padding-bottom: 10px;
        }
        .log-entry {
            margin-bottom: 8px;
            padding: 6px 8px;
            border-bottom: 1px dotted #4f4f4f;
            display: flex;
            align-items: flex-start;
            transition: background-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
            border-radius: 4px;
            opacity: 0;
            animation: logEntryFadeIn 0.5s forwards;
        }
         .log-entry:last-child { border-bottom: none; }
         .log-entry:hover { background-color: rgba(255, 255, 255, 0.05); transform: translateX(3px); }
         .log-icon { margin-right: 10px; width: 18px; text-align: center; font-size: 1.1em; line-height: 1.4; }
         .log-time { color: var(--text-muted-color); margin-right: 12px; flex-shrink: 0; font-size: 0.9em; }
         .log-message { flex-grow: 1; word-break: break-word; line-height: 1.5; }
         .log-error { color: var(--error-color); }
         .log-success { color: var(--success-color); }
         .log-info { color: var(--primary-color); }
         .log-warning { color: var(--warning-color); }
         .log-debug { color: #6e7681; font-style: italic; } /* GitHub Dimmed Italic */
         .log-writeback { color: var(--secondary-color); } /* Purple for writeback */

        @keyframes logEntryFadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* Modal Styling */
        .modal {
            position: fixed;
            z-index: 2000; /* Above moving blocks */
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.75);
            display: flex; /* Use flex directly */
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-speed-medium) ease, visibility var(--transition-speed-medium) ease;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--surface-solid-color);
            padding: 35px 40px;
            border: 1px solid var(--border-color-light);
            border-radius: var(--border-radius);
            width: 85%;
            max-width: 750px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
            position: relative;
            color: var(--text-color);
            max-height: 85vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform var(--transition-speed-medium) cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Elastic ease */
        }
        .modal.show .modal-content { transform: scale(1); }

         .modal-content h2 {
            color: var(--primary-color);
            margin-top: 0; text-align: center;
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 18px; margin-bottom: 28px; font-weight: 600;
         }
         .modal-content p, .modal-content ul { font-size: 1em; line-height: 1.8; margin-bottom: 20px; }
         .modal-content ul { padding-left: 35px; list-style: none; }
         .modal-content li::before {
             content: '‚úì'; color: var(--success-color);
             font-weight: bold; display: inline-block;
             width: 1.2em; margin-left: -1.3em; margin-right: 0.1em;
         }
         .modal-content strong { color: var(--primary-color); font-weight: 500; }
         .modal-content code { background-color: rgba(88, 166, 255, 0.1); padding: 3px 6px; border-radius: 5px; font-family: var(--font-mono); font-size: 0.9em; border: 1px solid rgba(88, 166, 255, 0.3); }
         .modal-content .attribution { margin-top: 35px; font-style: italic; text-align: right; font-size: 0.9em; color: var(--text-muted-color); }

        .close-button {
            color: var(--text-muted-color); position: absolute;
            top: 18px; right: 22px; font-size: 36px; font-weight: bold; line-height: 1;
            transition: color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
            cursor: pointer;
        }
        .close-button:hover { color: var(--error-color); transform: rotate(90deg); }

        /* Tooltip */
        #tooltip {
            position: absolute; display: none;
            background-color: rgba(22, 27, 34, 0.95); /* Darker background */
            color: var(--text-color);
            border: 1px solid var(--border-color-light);
            border-radius: 8px; padding: 12px 18px;
            font-size: 0.88em; z-index: 1500;
            pointer-events: none; white-space: pre-line; /* Allow line breaks */
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-width: 280px; font-family: var(--font-main);
            backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
            line-height: 1.6;
        }
        #tooltip strong { color: var(--primary-color); font-weight: 600; display: block; margin-bottom: 5px; font-size: 1.1em;}
        #tooltip span { color: var(--text-muted-color); margin-right: 5px; }


        /* Responsive Adjustments */
        @media (max-width: 992px) {
            .memory-grid { grid-template-columns: 1fr 1fr; gap: 30px; }
        }
        @media (max-width: 768px) {
            .main-container { padding: 0 10px; }
            .panel { flex-direction: column; align-items: stretch; gap: 10px; padding: 15px; }
            .panel label, .panel span { margin-right: 0; margin-bottom: 3px; display: block; text-align: left;}
            input[type="number"], input[type="text"], select, button { width: 100%; margin: 6px 0; }
            .memory-grid { grid-template-columns: 1fr; gap: 25px; }
            .memory-section { min-height: 300px; }
            h1 { font-size: 1.8em; }
            #log-container { padding: 15px; }
            #log { height: 250px; max-width: 100%; }
        }
         @media (max-width: 480px) {
            body { padding: 15px 5px; }
            h1 { font-size: 1.6em; margin-bottom: 20px; }
            button, select, input { padding: 12px 15px; font-size: 0.9em; }
            .memory-section h3 { font-size: 1.15em; }
            .block { height: 40px; line-height: 40px; font-size: 0.9em;}
            .modal-content { padding: 25px 20px; width: 95%; }
         }

    </style>
</head>
<body>
    <div class="main-container">
        <h1>Advanced Hybrid Virtual Memory Manager</h1>

        <div class="panel config">
            <label for="ramSizeInput">RAM:</label>
            <input type="number" id="ramSizeInput" value="4" min="1" max="20" title="RAM Size (Frames)">
            <label for="swapSizeInput">Swap:</label>
            <input type="number" id="swapSizeInput" value="4" min="0" max="20" title="Swap Space Size (Frames)">
            <label for="cacheSizeInput">Cache:</label>
            <input type="number" id="cacheSizeInput" value="3" min="0" max="10" title="Cache Size (Entries)">
            <button onclick="applyConfig()" title="Apply new sizes and reset simulation"><span class="icon">‚öôÔ∏è</span>Apply & Reset</button>
            <button id="aboutButton" class="secondary" title="Show information about this simulation"><span class="icon">‚ÑπÔ∏è</span>About</button>
        </div>

        <div class="panel controls">
            <label for="algorithm">Algorithm:</label>
            <select id="algorithm" title="Select page replacement algorithm for RAM eviction">
                <option value="fifo">FIFO</option>
                <option value="lru">LRU</option>
                <option value="lfu">LFU</option>
                <option value="lifo">LIFO</option>
                <option value="mru">MRU</option>
                <option value="random">Random</option>
            </select>
            <input type="text" id="processIdInput" placeholder="Process ID (e.g., P5)" title="Enter Process ID (P1-P20) or leave blank for random selection">
            <button onclick="allocateProcess()" title="Allocate the specified (or random) process to RAM"><span class="icon">‚ûï</span>Allocate</button>
            <button onclick="accessProcess()" title="Access the specified (or random) process"><span class="icon">üëÜ</span>Access</button>
            <button onclick="markProcessDirty()" class="secondary" title="Mark specified RAM process as 'dirty' (modified)"><span class="icon">‚úèÔ∏è</span>Write/Dirty</button>
            <button onclick="manualAddToCache()" class="secondary" title="Manually add process from RAM to Cache"><span class="icon">‚ö°</span>To Cache</button>
            <button onclick="clearCache()" class="danger" title="Remove all entries from the cache"><span class="icon">üßπ</span>Clear Cache</button>
            <button onclick="resetSimulation()" class="danger" title="Reset the entire simulation to initial state"><span class="icon">üîÑ</span>Reset Sim</button>
            <label for="simSpeed">Speed:</label>
             <select id="simSpeed" onchange="updateSimSpeed()" title="Adjust simulation animation speed">
                 <option value="2">Slow (0.5x)</option>
                 <option value="1.5">Slower (0.75x)</option>
                 <option value="1" selected>Normal (1x)</option>
                 <option value="0.5">Fast (2x)</option>
                 <option value="0.25">Faster (4x)</option>
                 <option value="0.1">Instant (10x)</option>
             </select>
        </div>

        <div class="panel stats-container">
            <span>Cache: <strong id="cacheHits">0</strong> H / <strong id="cacheAccesses">0</strong> Acc</span> |
            <span>RAM: <strong id="ramHits">0</strong> H / <strong id="ramAccesses">0</strong> Acc</span> |
            <span>Swap (Faults): <strong id="pageFaults">0</strong> F / <strong id="swapAccesses">0</strong> Acc</span> |
            <span>TLB: <strong id="tlbHits">0</strong> H / <strong id="tlbMisses">0</strong> M</span> |
            <span>Total Access: <strong id="totalAccesses">0</strong></span> |
            <span>Hit Rate: <strong id="hitRate">N/A</strong></span> |
            <span>Fault Rate: <strong id="faultRate">N/A</strong></span>
            <span id="thrashing-indicator">üö® THRASHING ALERT!</span>
        </div>

        <div class="memory-grid" id="memoryGrid">
            <div class="memory-section" id="cache-section">
                <h3><span class="icon">‚ö°</span> Cache</h3>
                 <div class="memory-usage-container">
                    <span id="cache-usage" class="memory-usage-text">0/3 Used</span>
                    <div class="progress-bar-container"><div id="cache-progress" class="progress-bar" style="background: linear-gradient(90deg, var(--cache-color-start), var(--cache-color-end));"></div></div>
                 </div>
                <div id="cache" class="block-container"></div>
            </div>
            <div class="memory-section" id="ram-section">
                <h3><span class="icon">üíæ</span> Main Memory (RAM)</h3>
                <div class="memory-usage-container">
                    <span id="ram-usage" class="memory-usage-text">0/4 Used</span>
                    <div class="progress-bar-container"><div id="ram-progress" class="progress-bar" style="background: linear-gradient(90deg, var(--ram-color-start), var(--ram-color-end));"></div></div>
                 </div>
                <div id="ram" class="block-container"></div>
            </div>
            <div class="memory-section" id="swap-section">
                <h3><span class="icon">üíø</span> Swap Space</h3>
                 <div class="memory-usage-container">
                    <span id="swap-usage" class="memory-usage-text">0/4 Used</span>
                    <div class="progress-bar-container"><div id="swap-progress" class="progress-bar" style="background: linear-gradient(90deg, var(--swap-color-start), var(--swap-color-end));"></div></div>
                 </div>
                <div id="swap" class="block-container"></div>
            </div>
        </div>

        <div id="log-container">
            <div id="log"><strong class="log-title">System Log</strong></div>
        </div>
        <div id="tooltip"></div>
    </div>

    <div id="aboutModal" class="modal">
      <div class="modal-content">
        <span class="close-button" id="closeModalButton">√ó</span>
        <h2>About Advanced Hybrid VMM</h2>
        <p>This simulation demonstrates concepts of a hybrid virtual memory system involving <strong>Cache</strong>, <strong>RAM</strong>, and <strong>Swap Space</strong> with enhanced features and visualizations.</p>
        <p><strong>Key Features:</strong></p>
        <ul>
            <li><strong>Memory Hierarchy:</strong> Visualizes processes in Cache (fast), RAM (medium), or Swap Space (slow).</li>
            <li><strong>Process Allocation/Access:</strong> Add/access processes, triggering placement and movement.</li>
            <li><strong>Caching:</strong> RAM hits move processes to the Cache (LRU eviction).</li>
            <li><strong>Page Replacement Algorithms:</strong> Select FIFO, LRU, LFU, LIFO, MRU, or Random for RAM eviction.</li>
            <li><strong><span style="color: var(--error-color);">Dirty Bit</span> Simulation:</strong> Processes in RAM can be marked 'dirty'. Evicting a dirty page simulates a slower write-back to Swap.</li>
            <li><strong><span style="color: var(--warning-color);">Thrashing Detection:</span></strong> Alerts if the recent page fault rate becomes excessively high.</li>
            <li><strong>Process Termination:</strong> Right-click a block to remove it entirely.</li>
            <li><strong>Dynamic Configuration & Speed Control:</strong> Adjust sizes and animation speed.</li>
            <li><strong>Detailed Info & Stats:</strong> Hover for info; view hits, faults, rates, and conceptual TLB performance.</li>
            <li><strong>Advanced Animations:</strong> Visual feedback for movement, state changes, and events.</li>
        </ul>
        <p><strong>Interactions:</strong></p>
        <ul>
            <li>Use controls to configure, allocate, access, mark dirty, or manage memory.</li>
            <li>Click a block to select it and trigger an access.</li>
            <li>Right-click a block to terminate the process.</li>
            <li>Hover over blocks for detailed information via tooltips.</li>
        </ul>
         <p class="attribution">Concept By: AALOK KUMAR YADAV</p>
      </div>
    </div>

    <script>
        // --- Global State ---
        let ramSize = 4;
        let swapSize = 4;
        let cacheSize = 3;
        const MAX_PROCESS_ID = 20;
        const MIN_PROCESS_KB = 512; // Increased min size
        const MAX_PROCESS_KB = 2 * 1024 * 1024; // Up to 2GB

        let ram = []; // Array of process IDs in RAM
        let swap = []; // Array of process IDs in Swap
        let cache = new Map(); // Map: processId -> { data: string, lastAccess: timestamp }
        let dirtyProcesses = new Set(); // Set of process IDs in RAM that are dirty

        // Tracking data for algorithms
        let accessOrder = []; // For LRU/MRU (RAM processes)
        let accessFrequency = {}; // For LFU { processId: count }
        let ramAddTime = {}; // For FIFO { processId: timestamp }
        let processSizes = {}; // { processId: sizeInKB }

        // Stats
        let stats = {
            cacheHits: 0, cacheAccesses: 0,
            ramHits: 0, ramAccesses: 0,
            pageFaults: 0, swapAccesses: 0,
            tlbHits: 0, tlbMisses: 0,
            totalAccesses: 0,
            writeBacks: 0
        };
        let accessHistory = []; // For thrashing detection (stores 'hit' or 'fault')
        const HISTORY_SIZE = 15;
        const THRASHING_THRESHOLD = 0.7; // 70% fault rate in history

        // Simulation Speed
        let simulationSpeedFactor = 1;
        const WRITE_BACK_DELAY_MS = 400; // Base delay for dirty writeback simulation

        // Utility
        const processPool = Array.from({ length: MAX_PROCESS_ID }, (_, i) => `P${i + 1}`);
        const logDiv = document.getElementById("log");
        const tooltipDiv = document.getElementById("tooltip");
        const memoryGrid = document.getElementById('memoryGrid'); // Container for moving blocks

        // --- Initialization ---
        function initSimulation() {
            ram = [];
            swap = [];
            cache.clear();
            dirtyProcesses.clear();
            accessOrder = [];
            accessFrequency = {};
            ramAddTime = {};
            processSizes = {};
            accessHistory = [];

            // Reset stats
            for (const key in stats) { stats[key] = 0; }

            // Generate random sizes
            for (let i = 1; i <= MAX_PROCESS_ID; i++) {
                const processId = `P${i}`;
                processSizes[processId] = getRandomInt(MIN_PROCESS_KB, MAX_PROCESS_KB);
            }
            logEvent("Simulation Initialized", "success", "üöÄ");
            logEvent(`Generated random sizes for ${MAX_PROCESS_ID} processes (Range: ${formatSize(MIN_PROCESS_KB)} - ${formatSize(MAX_PROCESS_KB)}).`, "debug");
            updateDisplay();
            updateStatsDisplay();
            checkThrashing(true); // Reset indicator
        }

        function applyConfig() {
             const newRamSize = parseInt(document.getElementById('ramSizeInput').value);
             const newSwapSize = parseInt(document.getElementById('swapSizeInput').value);
             const newCacheSize = parseInt(document.getElementById('cacheSizeInput').value);

             if (isNaN(newRamSize) || newRamSize < 1 || newRamSize > 20 ||
                 isNaN(newSwapSize) || newSwapSize < 0 || newSwapSize > 20 ||
                 isNaN(newCacheSize) || newCacheSize < 0 || newCacheSize > 10) {
                  logEvent("Invalid size config. Limits: RAM(1-20), Swap(0-20), Cache(0-10).", "error", "‚ùå");
                  document.getElementById('ramSizeInput').value = ramSize;
                  document.getElementById('swapSizeInput').value = swapSize;
                  document.getElementById('cacheSizeInput').value = cacheSize;
                  return;
             }

             ramSize = newRamSize;
             swapSize = newSwapSize;
             cacheSize = newCacheSize;
             logEvent(`Config Updated: RAM=${ramSize}, Swap=${swapSize}, Cache=${cacheSize}. Resetting...`, "info", "‚öôÔ∏è");
             initSimulation();
        }

        function resetSimulation() {
            logEvent("Simulation Reset", "info", "üîÑ");
            initSimulation();
        }

        // --- Core Logic ---

        function getProcessIdInput(required = false, checkExists = false) {
            const inputElement = document.getElementById('processIdInput');
            let processId = inputElement.value.trim().toUpperCase();
            let usedFallback = false;

            if (!processId || !/^P\d+$/.test(processId)) {
                usedFallback = true;
                const allocated = new Set([...ram, ...swap, ...cache.keys()]);
                const available = processPool.filter(p => !allocated.has(p));
                const allExisting = [...allocated];

                if (checkExists && allExisting.length > 0) { // Need an existing one (for access/dirty)
                     processId = allExisting[Math.floor(Math.random() * allExisting.length)];
                     logEvent(`No valid ID. Using random existing process: ${processId}`, "debug");
                } else if (!checkExists && available.length > 0) { // Need an available one (for allocate)
                     processId = available[Math.floor(Math.random() * available.length)];
                     logEvent(`No valid ID. Using random available process: ${processId}`, "debug");
                } else if (required) {
                    logEvent(`Valid Process ID required, but none available/suitable.`, "warning", "‚ö†Ô∏è");
                    inputElement.focus();
                    return null;
                } else {
                     logEvent(`No valid Process ID and no processes available/suitable.`, "warning", "‚ö†Ô∏è");
                     return null;
                }
            } else {
                 const num = parseInt(processId.substring(1));
                 if (num < 1 || num > MAX_PROCESS_ID) {
                     logEvent(`Process ID ${processId} out of range (P1-P${MAX_PROCESS_ID}).`, "error", "‚ùå");
                     inputElement.value = '';
                     return null;
                 }
            }

            if (!usedFallback) {
                inputElement.value = '';
            }
            return processId;
        }

        async function allocateProcess() {
            const processId = getProcessIdInput(false, false); // Not required, doesn't need to exist yet
            if (!processId) return;

            if (ram.includes(processId) || swap.includes(processId) || cache.has(processId)) {
                logEvent(`Process ${processId} already allocated.`, "warning", "‚ö†Ô∏è");
                await highlightExistingBlock(processId);
                return;
            }

            logEvent(`Allocating Process ${processId}...`, "info", "üì•");

            if (ram.length < ramSize) {
                // Direct Allocation
                ram.push(processId);
                const now = Date.now();
                updateTrackingOnAdd(processId, now);
                logEvent(`Process ${processId} allocated to RAM.`, "success", "‚úÖ");
                updateDisplay();
                await animateBlockAppearance(processId, 'ram', 'block-fade-in');
            } else {
                // Eviction Required
                logEvent(`RAM full. Evicting page via ${document.getElementById("algorithm").value.toUpperCase()}...`, "warning", "‚öñÔ∏è");
                const { victimId, writebackNeeded } = await evictPage(); // Evict returns victim and if writeback happened

                if (victimId) {
                    // Eviction animation handled within evictPage if writeback needed, otherwise fade out here
                    if (!writebackNeeded) {
                        await animateBlockRemoval(victimId, 'ram', 'block-fade-out');
                    }

                    let evictedDestination = 'Discarded';
                    let movePromise = Promise.resolve();

                    if (swap.length < swapSize) {
                        // Move Evicted to Swap
                        swap.push(victimId);
                        evictedDestination = 'Swap';
                        logEvent(`Process ${victimId} moved to Swap.`, "info", "üì¶");
                        movePromise = animateBlockMove(victimId, 'ram', 'swap');
                    } else {
                        logEvent(`Process ${victimId} evicted & discarded (Swap full).`, "warning", "üóëÔ∏è");
                    }

                    cleanUpTrackingData(victimId); // Clean up after move decision

                    // Allocate New Process
                    ram.push(processId);
                    const now = Date.now();
                    updateTrackingOnAdd(processId, now);
                    logEvent(`Process ${processId} allocated to RAM.`, "success", "‚úÖ");

                    updateDisplay(); // Render new state

                    // Run animations concurrently
                    await Promise.all([
                         animateBlockAppearance(processId, 'ram', 'block-fade-in'),
                         movePromise
                    ]);

                } else {
                     logEvent(`Allocation Failed: Could not evict page from RAM.`, "error", "‚ùå");
                     updateDisplay();
                }
            }
            updateStatsDisplay();
        }

        async function accessProcess() {
            const processId = getProcessIdInput(false, true); // Not required, but must exist
             if (!processId) return;

            logEvent(`Accessing Process ${processId}...`, "info", "üîç");
            stats.totalAccesses++;
            const now = Date.now();
            let accessType = 'miss'; // Default

            // 1. Check Cache
            if (cache.has(processId)) {
                stats.cacheHits++; stats.cacheAccesses++; stats.tlbHits++;
                accessType = 'hit';
                logEvent(`Cache Hit: Process ${processId}.`, "success", "üéØ");
                const entry = cache.get(processId);
                entry.lastAccess = now;
                cache.set(processId, entry); // Update access time
                await highlightBlock(processId, 'cache', 'block-highlight');
                updateDisplay(['cache']); // Update cache usage/progress
            }
            // 2. Check RAM
            else if (ram.includes(processId)) {
                stats.ramHits++; stats.ramAccesses++; stats.tlbHits++;
                accessType = 'hit';
                logEvent(`RAM Hit: Process ${processId}. Moving to Cache...`, "success", "‚úÖ");
                updateUsageTracking(processId, now); // Update LRU/LFU etc.
                await highlightBlock(processId, 'ram', 'block-highlight');
                await addToCache(processId, now); // Add to cache (handles cache eviction)
                updateDisplay(); // Update all displays
            }
            // 3. Check Swap -> Page Fault
            else if (swap.includes(processId)) {
                stats.pageFaults++; stats.swapAccesses++; stats.tlbMisses++;
                accessType = 'fault';
                logEvent(`Page Fault: Process ${processId} in Swap. Loading...`, "warning", "üìâ");
                await handlePageFault(processId, now);
                // updateDisplay called within handlePageFault
            }
            // 4. Not Found
            else {
                 logEvent(`Access Failed: Process ${processId} not found.`, "error", "‚ùì");
                 // No stats update here as it wasn't a valid access attempt on existing memory
                 stats.totalAccesses--; // Decrement as it wasn't a real access
            }

            // Update history for thrashing detection
            if (accessType !== 'miss') { // Only record valid accesses
                 accessHistory.push(accessType === 'fault' ? 'fault' : 'hit');
                 if (accessHistory.length > HISTORY_SIZE) {
                     accessHistory.shift(); // Keep history size fixed
                 }
                 checkThrashing();
            }

            updateStatsDisplay();
        }

        async function markProcessDirty() {
             const processId = getProcessIdInput(true, true); // Require input, must exist
             if (!processId) return;

             if (ram.includes(processId)) {
                 if (dirtyProcesses.has(processId)) {
                    logEvent(`Process ${processId} is already dirty.`, "info", "‚úèÔ∏è");
                    await highlightBlock(processId, 'ram', 'block-highlight');
                 } else {
                    dirtyProcesses.add(processId);
                    logEvent(`Process ${processId} marked as dirty.`, "warning", "‚úèÔ∏è");
                    updateDisplay(['ram']); // Update display to show dirty state
                    await animateBlockStateChange(processId, 'ram', 'block-marked-dirty');
                 }
             } else {
                 logEvent(`Cannot mark dirty: Process ${processId} is not in RAM.`, "error", "‚ùå");
                 await highlightExistingBlock(processId);
             }
        }


        async function manualAddToCache() {
            const processId = getProcessIdInput(true, true); // Require input, must exist
            if (!processId) return;

            if (cacheSize <= 0) { logEvent("Cache disabled (size 0).", "warning", "‚ö†Ô∏è"); return; }
            if (cache.has(processId)) {
                 logEvent(`Process ${processId} already in cache. Updating access.`, "info", "üí°");
                 const entry = cache.get(processId);
                 entry.lastAccess = Date.now();
                 cache.set(processId, entry);
                 await highlightBlock(processId, 'cache', 'block-highlight', 300);
                 updateDisplay(['cache']);
                 return;
            }

            if (ram.includes(processId)) {
                stats.ramAccesses++; // Count as a RAM access conceptually
                stats.totalAccesses++; // And a total access
                logEvent(`Manually adding ${processId} (RAM) to Cache...`, "info", "‚û°Ô∏è");
                const now = Date.now();
                updateUsageTracking(processId, now); // Update RAM stats
                await addToCache(processId, now); // Handles logic and animations
                updateDisplay();
                accessHistory.push('hit'); // Count as hit for thrashing calc
                 if (accessHistory.length > HISTORY_SIZE) accessHistory.shift();
                 checkThrashing();
                 updateStatsDisplay();
            } else {
                logEvent(`Cannot add to Cache: Process ${processId} not in RAM.`, "warning", "‚ö†Ô∏è");
                await highlightExistingBlock(processId);
            }
        }

        async function clearCache() {
            if (cache.size === 0) { logEvent("Cache already empty.", "info", "‚úÖ"); return; }
            logEvent("Clearing Cache...", "info", "üßπ");

            const fadePromises = [];
            cache.forEach((value, processId) => {
                 fadePromises.push(animateBlockRemoval(processId, 'cache', 'block-fade-out'));
             });
            await Promise.all(fadePromises);

            cache.clear();
            logEvent("Cache Cleared.", "success", "‚ú®");
            updateDisplay(['cache']);
            updateStatsDisplay(); // Reset cache stats implicitly? No, keep history.
        }

        async function endProcess(processId) {
            logEvent(`Terminating Process ${processId}...`, "warning", "‚ùå");
            let foundLocation = null;
            let removalPromise = Promise.resolve();

            if (cache.has(processId)) {
                foundLocation = 'cache';
                removalPromise = animateBlockRemoval(processId, 'cache', 'block-terminate');
                cache.delete(processId);
                logEvent(`Process ${processId} removed from Cache.`, "info", "üóëÔ∏è");
            }
            if (ram.includes(processId)) {
                const ramIndex = ram.indexOf(processId);
                if (ramIndex > -1) {
                     if (!foundLocation) {
                        foundLocation = 'ram';
                        removalPromise = animateBlockRemoval(processId, 'ram', 'block-terminate');
                     }
                     ram.splice(ramIndex, 1);
                     logEvent(`Process ${processId} removed from RAM.`, "info", "üóëÔ∏è");
                }
            }
             if (swap.includes(processId)) {
                const swapIndex = swap.indexOf(processId);
                 if (swapIndex > -1) {
                     if (!foundLocation) {
                        foundLocation = 'swap';
                        removalPromise = animateBlockRemoval(processId, 'swap', 'block-terminate');
                     }
                     swap.splice(swapIndex, 1);
                     logEvent(`Process ${processId} removed from Swap.`, "info", "üóëÔ∏è");
                 }
            }


            if (foundLocation) {
                await removalPromise;
                cleanUpTrackingData(processId); // Also cleans dirty status
                logEvent(`Process ${processId} terminated.`, "success", "‚úîÔ∏è");
            } else {
                logEvent(`Termination Failed: Process ${processId} not found.`, "error", "‚ùì");
            }

            updateDisplay();
            updateStatsDisplay();
        }

        // --- Helper Functions ---

        async function handlePageFault(processId, accessTime) {
            // 1. Animate removal from Swap
            await animateBlockRemoval(processId, 'swap', 'block-fade-out');
            const swapIndex = swap.indexOf(processId);
            if (swapIndex > -1) swap.splice(swapIndex, 1);
            else { logEvent(`Error: ${processId} vanished from Swap during Page Fault!`, "error", "üëª"); return; }
            logEvent(`Process ${processId} removed from Swap.`, "debug");

            let evictedProcessId = null;
            let ramEvictionMovePromise = Promise.resolve();
            let writebackOccurred = false;

            // 2. Check for RAM Eviction
            if (ram.length >= ramSize) {
                logEvent(`RAM full. Evicting page via ${document.getElementById("algorithm").value.toUpperCase()}...`, "warning", "‚öñÔ∏è");
                const { victimId, writebackNeeded } = await evictPage();
                evictedProcessId = victimId;
                writebackOccurred = writebackNeeded;

                if (evictedProcessId) {
                    // Eviction animation (fade or writeback pulse) handled in evictPage if dirty
                    if (!writebackOccurred) {
                         await animateBlockRemoval(evictedProcessId, 'ram', 'block-fade-out');
                    }

                    if (swap.length < swapSize) {
                        swap.push(evictedProcessId);
                        logEvent(`Process ${evictedProcessId} moved to Swap.`, "info", "üì¶");
                        ramEvictionMovePromise = animateBlockMove(evictedProcessId, 'ram', 'swap');
                    } else {
                        logEvent(`Process ${evictedProcessId} evicted & discarded (Swap full).`, "warning", "üóëÔ∏è");
                    }
                    cleanUpTrackingData(evictedProcessId);
                } else {
                    logEvent(`Page Fault Failed: Could not evict page. ${processId} load aborted.`, "error", "‚ùå");
                    // Process is now out of swap, effectively discarded
                    updateDisplay();
                    return;
                }
            }

            // 3. Add faulted process to RAM
            ram.push(processId);
            updateTrackingOnAdd(processId, accessTime);
            logEvent(`Process ${processId} loaded into RAM.`, "success", "‚úÖ");
            updateDisplay(); // Render the new state

            // 4. Animate Page-In and potential Eviction-Move
            const pageInPromise = animateBlockMove(processId, 'swap', 'ram', true);
            await Promise.all([pageInPromise, ramEvictionMovePromise]);

            // 5. Add to cache
             await addToCache(processId, accessTime);
             updateDisplay(); // Final update potentially including cache changes
        }

        async function evictPage() {
            if (ram.length === 0) { logEvent("Eviction skipped: RAM empty.", "debug"); return { victimId: null, writebackNeeded: false }; }

            const algorithm = document.getElementById("algorithm").value;
            let victimId = null;
            let validRamProcesses = ram.filter(p => p && processPool.includes(p));
            if (validRamProcesses.length === 0) { logEvent("Eviction Failed: No valid processes in RAM.", "error", "‚ùå"); return { victimId: null, writebackNeeded: false }; }

            // --- Algorithm Logic ---
            let candidate = validRamProcesses[0];
            switch (algorithm) {
                 case "fifo": victimId = validRamProcesses.reduce((oldest, p) => (ramAddTime[p] || Infinity) < (ramAddTime[oldest] || Infinity) ? p : oldest, candidate); break;
                 case "lru":
                     for (const p_ordered of accessOrder) { if (validRamProcesses.includes(p_ordered)) { victimId = p_ordered; break; } }
                     if (!victimId) victimId = validRamProcesses[0];
                     break;
                 case "lfu":
                     victimId = validRamProcesses.reduce((leastFreq, p) => {
                         const freqP = accessFrequency[p] || 0; const freqLeast = accessFrequency[leastFreq] || 0;
                         if (freqP < freqLeast) return p;
                         if (freqP === freqLeast) return (ramAddTime[p] || Infinity) < (ramAddTime[leastFreq] || Infinity) ? p : leastFreq;
                         return leastFreq;
                     }, candidate);
                     break;
                 case "lifo": victimId = validRamProcesses.reduce((newest, p) => (ramAddTime[p] || 0) > (ramAddTime[newest] || 0) ? p : newest, candidate); break;
                 case "mru":
                     for (let i = accessOrder.length - 1; i >= 0; i--) { if (validRamProcesses.includes(accessOrder[i])) { victimId = accessOrder[i]; break; } }
                     if (!victimId) victimId = validRamProcesses[validRamProcesses.length - 1];
                     break;
                 case "random": default: victimId = validRamProcesses[Math.floor(Math.random() * validRamProcesses.length)]; break;
            }

            let writebackNeeded = false;
            if (victimId) {
                logEvent(`Eviction choice (${algorithm.toUpperCase()}): Process ${victimId}`, "debug");
                const ramIndex = ram.indexOf(victimId);
                if (ramIndex > -1) {
                    // --- Dirty Check ---
                    if (dirtyProcesses.has(victimId)) {
                        writebackNeeded = true;
                        stats.writeBacks++;
                        logEvent(`Process ${victimId} is dirty. Simulating Write-Back...`, "log-writeback", "üíæ");
                        // Animate write-back *before* removing visually
                        await animateBlockStateChange(victimId, 'ram', 'block-write-back');
                        await wait(WRITE_BACK_DELAY_MS); // Simulate write delay
                        dirtyProcesses.delete(victimId); // Clean the bit after write
                        logEvent(`Write-Back complete for ${victimId}.`, "log-writeback", "‚úîÔ∏è");
                    }
                    // --- Remove from RAM array ---
                     ram.splice(ramIndex, 1);
                     // Tracking data (accessOrder, freq, addTime) cleaned up in calling function after move decision
                } else {
                     logEvent(`Error: Eviction victim ${victimId} not found in RAM array.`, "error", "‚ùå");
                     victimId = null; // Failed
                }
            } else {
                 logEvent(`Eviction failed: No victim determined.`, "error", "‚ùå");
            }
            return { victimId, writebackNeeded };
        }


        function cleanUpTrackingData(processId) {
             accessOrder = accessOrder.filter(p => p !== processId);
             delete accessFrequency[processId];
             delete ramAddTime[processId];
             dirtyProcesses.delete(processId); // Ensure dirty bit is cleared
             if (cache.has(processId)) {
                 cache.delete(processId);
                 logEvent(`Process ${processId} removed from cache during cleanup.`, "debug");
             }
        }

        function updateTrackingOnAdd(processId, timestamp) {
             ramAddTime[processId] = timestamp;
             accessFrequency[processId] = 1;
             accessOrder = accessOrder.filter(p => p !== processId);
             accessOrder.push(processId);
             dirtyProcesses.delete(processId); // Process starts clean
        }

        function updateUsageTracking(processId, accessTime) {
             accessOrder = accessOrder.filter(p => p !== processId);
             accessOrder.push(processId);
             accessFrequency[processId] = (accessFrequency[processId] || 0) + 1;
        }

        async function addToCache(processId, accessTime) {
            if (cacheSize <= 0) return;

            let cacheEvictionPromise = Promise.resolve();

            let existingEntry = cache.get(processId);
            if (existingEntry) {
                existingEntry.lastAccess = accessTime;
                cache.set(processId, existingEntry);
                logEvent(`Process ${processId} cache access time updated.`, "debug");
                await highlightBlock(processId, 'cache', 'block-highlight', 250);
                updateDisplay(['cache']);
                return;
            }

            if (cache.size >= cacheSize) {
                let lruKey = null;
                let oldestTime = Infinity;
                cache.forEach((value, key) => { if (value.lastAccess < oldestTime) { oldestTime = value.lastAccess; lruKey = key; } });

                if (lruKey) {
                    logEvent(`Cache full. Evicting ${lruKey} (LRU).`, "warning", "üí®");
                    cache.delete(lruKey);
                    cacheEvictionPromise = animateBlockRemoval(lruKey, 'cache', 'block-fade-out');
                } else if (cache.size > 0) {
                     logEvent(`Cache full but failed to find LRU entry.`, "error", "‚ùå");
                     return;
                }
            }

            await cacheEvictionPromise; // Wait for potential eviction animation

            if(cache.size < cacheSize){
                cache.set(processId, { data: `Data for ${processId}`, lastAccess: accessTime });
                logEvent(`Process ${processId} added to cache.`, "success", "üí°");
                updateDisplay(['cache']); // Render new state
                await animateBlockAppearance(processId, 'cache', 'block-fade-in');
             } else {
                  logEvent(`Internal Error: Failed add to cache post-eviction check.`, "error", "‚ùå");
             }
        }

         // --- Thrashing Detection ---
         function checkThrashing(forceReset = false) {
             const indicator = document.getElementById('thrashing-indicator');
             if (forceReset || accessHistory.length < HISTORY_SIZE / 2) { // Don't check with too little data
                 indicator.style.display = 'none';
                 return;
             }

             const faultsInHistory = accessHistory.filter(a => a === 'fault').length;
             const faultRate = faultsInHistory / accessHistory.length;

             if (faultRate >= THRASHING_THRESHOLD) {
                 if (indicator.style.display === 'none') {
                     logEvent(`High Page Fault Rate (${(faultRate * 100).toFixed(0)}%)! Potential Thrashing!`, "error", "üö®");
                 }
                 indicator.style.display = 'inline';
             } else {
                 indicator.style.display = 'none';
             }
         }

        // --- Display & Animation ---

        function updateDisplay(sectionsToUpdate = ['cache', 'ram', 'swap']) {
            const containers = {
                cache: document.getElementById("cache"),
                ram: document.getElementById("ram"),
                swap: document.getElementById("swap")
            };
            const usageTexts = {
                cache: document.getElementById("cache-usage"),
                ram: document.getElementById("ram-usage"),
                swap: document.getElementById("swap-usage")
            };
             const progressBars = {
                 cache: document.getElementById("cache-progress"),
                 ram: document.getElementById("ram-progress"),
                 swap: document.getElementById("swap-progress")
            };
             const counts = { cache: cache.size, ram: ram.length, swap: swap.length };
             const sizes = { cache: cacheSize, ram: ramSize, swap: swapSize };
             const dataArrays = { cache: [...cache.keys()], ram: ram, swap: swap }; // Use keys for cache rendering order

             sectionsToUpdate.forEach(section => {
                const container = containers[section];
                if (!container) return;
                container.innerHTML = ''; // Clear only necessary sections

                 // Sort cache by access time for consistent (though not guaranteed visual) order
                 const itemsToRender = (section === 'cache')
                     ? [...cache.entries()].sort(([,a], [,b]) => a.lastAccess - b.lastAccess).map(([key]) => key)
                     : dataArrays[section];

                 itemsToRender.forEach(p => {
                    if (p) container.insertAdjacentHTML('beforeend', createBlockHTML(p, section));
                 });

                 // Update usage text and progress bar
                 const count = counts[section];
                 const size = sizes[section];
                 usageTexts[section].textContent = `${count}/${size} Used`;
                 const percentage = size > 0 ? (count / size) * 100 : 0;
                 progressBars[section].style.width = `${percentage}%`;
             });

             // Attach event listeners using delegation on memoryGrid
             memoryGrid.removeEventListener('click', handleBlockEvent);
             memoryGrid.removeEventListener('contextmenu', handleBlockEvent);
             memoryGrid.removeEventListener('mouseover', handleBlockEvent);
             memoryGrid.removeEventListener('mouseout', handleBlockEvent);

             memoryGrid.addEventListener('click', handleBlockEvent);
             memoryGrid.addEventListener('contextmenu', handleBlockEvent);
             memoryGrid.addEventListener('mouseover', handleBlockEvent);
             memoryGrid.addEventListener('mouseout', handleBlockEvent);
        }

        // --- Delegated Event Handler ---
         function handleBlockEvent(event) {
             const block = event.target.closest('.block');
             if (!block) {
                 if(event.type === 'mouseout') hideTooltip(); // Hide tooltip if mouse leaves the grid area
                 return;
             }

             const processId = block.getAttribute('data-process-id');
             const type = block.closest('.memory-section')?.id.split('-')[0]; // cache, ram, swap

             if (!processId || !type) return;

             switch(event.type) {
                 case 'click':
                     document.getElementById('processIdInput').value = processId;
                     logEvent(`Clicked ${processId}, accessing...`, 'debug');
                     accessProcess();
                     break;
                 case 'contextmenu':
                     event.preventDefault();
                     logEvent(`Right-clicked ${processId}, terminating...`, 'debug');
                     endProcess(processId);
                     break;
                 case 'mouseover':
                     showTooltip(block, processId, type);
                     break;
                 case 'mouseout':
                     hideTooltip();
                     break;
             }
         }


        // --- HTML Creation ---
         function createBlockHTML(processId, type) {
             let className = 'block';
             if (type === 'ram') className += ' in-ram';
             else if (type === 'swap') className += ' in-swap';
             else if (type === 'cache') className += ' in-cache';
             if (type === 'ram' && dirtyProcesses.has(processId)) {
                 className += ' block-dirty';
             }
             return `<div class="${className}" id="block-${type}-${processId}" data-process-id="${processId}">${processId}</div>`;
         }

        // --- Logging ---
        function logEvent(message, type = "info", icon = null) {
            if (!logDiv) { console.error("Log div not found!"); return; }

            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 2 });
            let typeClass = 'log-info'; let logIcon = icon;

            switch(type) {
                case 'success': typeClass = 'log-success'; if(!logIcon) logIcon = '‚úÖ'; break;
                case 'warning': typeClass = 'log-warning'; if(!logIcon) logIcon = '‚ö†Ô∏è'; break;
                case 'error':   typeClass = 'log-error';   if(!logIcon) logIcon = '‚ùå'; break;
                case 'debug':   typeClass = 'log-debug';   if(!logIcon) logIcon = 'üêû'; break;
                case 'log-writeback': typeClass = 'log-writeback'; if(!logIcon) logIcon = 'üíæ'; break; // Specific for writeback
                case 'info': default: typeClass = 'log-info'; if(!logIcon) logIcon = '‚ÑπÔ∏è'; break;
            }

            const entryDiv = document.createElement('div');
            entryDiv.className = 'log-entry';
            entryDiv.innerHTML = `<span class="log-icon ${typeClass}">${logIcon || ''}</span><span class="log-time">[${time}]</span><span class="log-message ${typeClass}">${message}</span>`;

            const wasScrolledToBottom = Math.abs(logDiv.scrollHeight - logDiv.clientHeight - logDiv.scrollTop) < 5;
            logDiv.appendChild(entryDiv);
            if (wasScrolledToBottom) logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll only if already at bottom
        }

        // --- Animation Helpers ---
        function getAnimationPromise(element, eventName = 'animationend') {
             return new Promise(resolve => {
                 const handler = (event) => {
                     if (event.target === element) {
                         element.removeEventListener(eventName, handler);
                         resolve();
                     }
                 };
                 element.addEventListener(eventName, handler);
                 // Safety timeout
                 setTimeout(() => {
                     element.removeEventListener(eventName, handler);
                     resolve();
                 }, getSimulationDuration(1500)); // Increased safety margin
             });
         }

        async function highlightBlock(processId, location, animationClass = 'block-highlight', duration = 700) {
             const blockElement = document.getElementById(`block-${location}-${processId}`);
             if (blockElement) {
                 blockElement.classList.remove('block-highlight', 'block-write-back', 'block-marked-dirty'); // Clear potentially interfering anims
                 void blockElement.offsetWidth; // Reflow
                 blockElement.classList.add(animationClass);
                 await getAnimationPromise(blockElement);
                 // Don't remove immediately, let CSS handle removal if animation is non-infinite
                 // Only remove if it's a pulse style animation after duration
                 if (animationClass.includes('pulse') || animationClass.includes('highlight')) {
                      setTimeout(() => {
                         if(blockElement) blockElement.classList.remove(animationClass);
                     }, getSimulationDuration(duration));
                 }

             } else { logEvent(`Highlight Failed: Block ${location}-${processId} not found.`, "debug"); }
         }

        async function highlightExistingBlock(processId) {
             if (cache.has(processId)) await highlightBlock(processId, 'cache');
             else if (ram.includes(processId)) await highlightBlock(processId, 'ram');
             else if (swap.includes(processId)) await highlightBlock(processId, 'swap');
             else logEvent(`Highlight Failed: ${processId} not found.`, 'debug');
        }

        async function animateBlockAppearance(processId, location, animationClass) {
             const blockElement = document.getElementById(`block-${location}-${processId}`);
             if (blockElement) {
                 blockElement.style.opacity = '0'; // Start invisible if fading/sliding in
                 await wait(20);
                 blockElement.classList.add(animationClass);
                 await getAnimationPromise(blockElement);
                 blockElement.classList.remove(animationClass);
                 blockElement.style.opacity = '1'; // Ensure fully visible
             }
         }

        async function animateBlockRemoval(processId, location, animationClass) {
             const blockElement = document.getElementById(`block-${location}-${processId}`);
             if (blockElement) {
                 blockElement.style.zIndex = '5'; // Ensure it's above others during removal anim
                 blockElement.classList.add(animationClass);
                 await getAnimationPromise(blockElement);
                 // Element removed by updateDisplay later
             }
         }

        async function animateBlockStateChange(processId, location, animationClass) {
            const blockElement = document.getElementById(`block-${location}-${processId}`);
            if (blockElement) {
                blockElement.classList.add(animationClass);
                await getAnimationPromise(blockElement);
                // For non-infinite animations, remove the class after completion
                if (!blockElement.style.animationIterationCount || blockElement.style.animationIterationCount !== 'infinite') {
                     blockElement.classList.remove(animationClass);
                }
            }
        }

        async function animateBlockMove(processId, fromLocation, toLocation, isPageIn = false) {
            const fromElement = document.getElementById(`block-${fromLocation}-${processId}`);
            const toContainer = document.getElementById(toLocation);
            if (!fromElement || !toContainer?.offsetParent) { // Check offsetParent to ensure target is visible/layouted
                 logEvent(`Move Anim Failed: Src/Dest missing for ${processId} (${fromLocation} -> ${toLocation})`, "error", "‚ùå");
                 return;
             }

             // Clone
             const movingBlock = fromElement.cloneNode(true);
             movingBlock.id = `moving-${processId}-${Date.now()}`;
             movingBlock.classList.add('block-moving');
             movingBlock.style.width = `${fromElement.offsetWidth}px`;
             movingBlock.style.height = `${fromElement.offsetHeight}px`;

             // Get initial position relative to viewport
             const startRect = fromElement.getBoundingClientRect();
             movingBlock.style.left = `${startRect.left}px`;
             movingBlock.style.top = `${startRect.top}px`;

             // Temporarily hide original element (don't remove, updateDisplay handles data)
             fromElement.style.opacity = '0';
             fromElement.style.pointerEvents = 'none';

             // Add clone to the main grid container for consistent positioning context
             memoryGrid.appendChild(movingBlock);

             // --- Calculate Target Position ---
             // Estimate where the block *will* be placed by updateDisplay.
             // Find the target container's element and estimate the position of the next block.
             const targetSectionElement = document.getElementById(`${toLocation}-section`);
             const targetContainerElement = document.getElementById(toLocation); // The .block-container div
             const targetRect = targetContainerElement.getBoundingClientRect();

             // Estimate Y position: assumes blocks stack vertically with gap
             const blockHeight = movingBlock.offsetHeight;
             const blockGap = 10; // Match .block-container gap
             let targetBlockIndex;
             if (toLocation === 'cache') targetBlockIndex = cache.size; // Size *before* potential add
             else if (toLocation === 'ram') targetBlockIndex = ram.length;
             else if (toLocation === 'swap') targetBlockIndex = swap.length;
             else targetBlockIndex = 0;

             // Calculate vertical offset within the container
             const verticalOffsetInContainer = 5 + targetBlockIndex * (blockHeight + blockGap); // 5 is approx padding-top

             // Calculate target X and Y relative to viewport
             const targetX = targetRect.left + (targetRect.width / 2) - (startRect.width / 2); // Center horizontally
             const targetY = targetRect.top + verticalOffsetInContainer;

             // --- Trigger the Move Animation ---
             await wait(50); // Short delay crucial for transition to register start/end states

             movingBlock.style.left = `${targetX}px`;
             movingBlock.style.top = `${targetY}px`;
             movingBlock.style.transform = 'scale(1) rotate(0deg)'; // Animate scale/rotation back to normal

             // --- Wait for Transition and Clean Up ---
             await getAnimationPromise(movingBlock, 'transitionend'); // Specifically wait for transition

             // Remove the clone
             if(movingBlock.parentNode === memoryGrid) { // Check parent before removing
                memoryGrid.removeChild(movingBlock);
             }

             // Make the *actual* block visible in the target location
             // updateDisplay should have already placed the real block element
             const finalBlockId = `block-${toLocation}-${processId}`;
             const finalElement = document.getElementById(finalBlockId);
             if (finalElement) {
                  // Optional: Add a final "settle" animation
                 finalElement.style.opacity = '0'; // May already be 0 from updateDisplay if new
                 finalElement.style.transform = 'scale(0.8)';
                 await wait(20);
                 finalElement.style.transition = 'opacity var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease';
                 finalElement.style.opacity = '1';
                 finalElement.style.transform = 'scale(1)';
                 await getAnimationPromise(finalElement, 'transitionend');
                 finalElement.style.transition = ''; // Reset transition
                 finalElement.style.transform = '';
             } else {
                 logEvent(`Move Anim Warning: Final block ${finalBlockId} not found after move!`, 'warning', '‚ùì');
                 // Ensure original block is visible again if something went wrong with target
                 // Although updateDisplay should handle this based on the data arrays
                 // fromElement.style.opacity = '1';
                 // fromElement.style.pointerEvents = 'auto';
             }
        }


        // --- Tooltip ---
        function showTooltip(element, processId, type) {
            const sizeInKB = processSizes[processId] || 0;
            const formattedSize = formatSize(sizeInKB);
            let content = `<strong>${processId}</strong><span>Size:</span> ${formattedSize}`;

            if (type === 'ram') {
                const freq = accessFrequency[processId] || 0;
                const added = ramAddTime[processId] ? new Date(ramAddTime[processId]).toLocaleTimeString() : '-';
                const isDirty = dirtyProcesses.has(processId);
                content += `\n<span>Freq:</span> ${freq}\n<span>Added:</span> ${added}`;
                if (isDirty) content += `\n<span style="color: var(--error-color);">State:</span> Dirty`;
                else content += `\n<span>State:</span> Clean`;
            } else if (type === 'cache') {
                const cacheEntry = cache.get(processId);
                const accessed = cacheEntry ? new Date(cacheEntry.lastAccess).toLocaleTimeString() : '-';
                content += `\n<span>Cache Access:</span> ${accessed}`;
            } else if (type === 'swap') {
                content += `\n<span>Location:</span> Swap`;
            }

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';

            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltipDiv.getBoundingClientRect(); // Measure *after* setting content

            // Prefer below, then above, then try side if needed (basic)
            let top = rect.bottom + 8 + window.scrollY;
            let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2) + window.scrollX;

            // Adjust X position first
            const margin = 10;
            if (left < margin) left = margin;
            if (left + tooltipRect.width > window.innerWidth - margin) {
                left = window.innerWidth - tooltipRect.width - margin;
            }

            // Adjust Y position if needed
            if (top + tooltipRect.height > window.innerHeight + window.scrollY - margin) {
                // Try placing above
                top = rect.top - tooltipRect.height - 8 + window.scrollY;
                // If still off-screen above (unlikely unless element is huge)
                if (top < window.scrollY + margin) {
                    top = rect.bottom + 8 + window.scrollY; // Revert to below (best effort)
                }
            }

            tooltipDiv.style.top = `${top}px`;
            tooltipDiv.style.left = `${left}px`;
            tooltipDiv.style.opacity = '0'; // Start fade in
             void tooltipDiv.offsetWidth; // Trigger reflow
             tooltipDiv.style.transition = 'opacity 0.15s ease';
             tooltipDiv.style.opacity = '1';
        }

        function hideTooltip() {
            tooltipDiv.style.opacity = '0';
             // Use timeout matching transition to set display none *after* fade out
             setTimeout(() => {
                 if (tooltipDiv.style.opacity === '0') { // Check if still hidden
                     tooltipDiv.style.display = 'none';
                 }
             }, 150);
        }

        // --- Stats Display ---
        function updateStatsDisplay() {
            document.getElementById('cacheHits').textContent = stats.cacheHits;
            document.getElementById('cacheAccesses').textContent = stats.cacheAccesses;
            document.getElementById('ramHits').textContent = stats.ramHits;
            document.getElementById('ramAccesses').textContent = stats.ramAccesses;
            document.getElementById('pageFaults').textContent = stats.pageFaults;
            document.getElementById('swapAccesses').textContent = stats.swapAccesses;
            document.getElementById('tlbHits').textContent = stats.tlbHits;
            document.getElementById('tlbMisses').textContent = stats.tlbMisses;
            document.getElementById('totalAccesses').textContent = stats.totalAccesses;

            const totalMemAccesses = stats.cacheAccesses + stats.ramAccesses + stats.swapAccesses;
            const totalMemHits = stats.cacheHits + stats.ramHits;
            const hitRate = totalMemAccesses > 0 ? ((totalMemHits / totalMemAccesses) * 100).toFixed(1) + '%' : 'N/A';
            const faultRate = totalMemAccesses > 0 ? ((stats.pageFaults / totalMemAccesses) * 100).toFixed(1) + '%' : 'N/A';

            document.getElementById('hitRate').textContent = hitRate;
            document.getElementById('faultRate').textContent = faultRate;

            // Update usage displays (already done in updateDisplay, but safe to repeat)
            document.getElementById('ram-usage').textContent = `${ram.length}/${ramSize} Used`;
            document.getElementById('swap-usage').textContent = `${swap.length}/${swapSize} Used`;
            document.getElementById('cache-usage').textContent = `${cache.size}/${cacheSize} Used`;

             document.getElementById('ram-progress').style.width = ramSize > 0 ? `${(ram.length / ramSize) * 100}%` : '0%';
             document.getElementById('swap-progress').style.width = swapSize > 0 ? `${(swap.length / swapSize) * 100}%` : '0%';
             document.getElementById('cache-progress').style.width = cacheSize > 0 ? `${(cache.size / cacheSize) * 100}%` : '0%';

        }

        // --- Simulation Speed ---
        function updateSimSpeed() {
            const speedSelect = document.getElementById('simSpeed');
            simulationSpeedFactor = parseFloat(speedSelect.value);
            document.documentElement.style.setProperty('--sim-speed-factor', simulationSpeedFactor);
            logEvent(`Simulation speed set to ${speedSelect.options[speedSelect.selectedIndex].text}`, 'info', '‚è±Ô∏è');
        }

        function getSimulationDuration(baseDuration) {
            // Ensure minimum duration for instant speed unless base is 0
            if (simulationSpeedFactor <= 0.1 && baseDuration > 0) return 10;
            return baseDuration * simulationSpeedFactor;
        }

        // Utility wait function respecting simulation speed
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, getSimulationDuration(ms)));
        }

        // --- Utilities ---
        function formatSize(kb) {
            if (kb >= 1024 * 1024) return (kb / (1024 * 1024)).toFixed(1) + ' GB';
            if (kb >= 1024) return (kb / 1024).toFixed(1) + ' MB';
            return kb + ' KB';
        }

        function getRandomInt(min, max) {
             min = Math.ceil(min); max = Math.floor(max);
             return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- Modal Logic ---
         document.addEventListener('DOMContentLoaded', () => {
             // Set initial values
             document.getElementById('ramSizeInput').value = ramSize;
             document.getElementById('swapSizeInput').value = swapSize;
             document.getElementById('cacheSizeInput').value = cacheSize;
             updateSimSpeed();

             initSimulation(); // Initialize

             // Modal setup
             const modal = document.getElementById("aboutModal");
             const btn = document.getElementById("aboutButton");
             const span = document.getElementById("closeModalButton");

             btn.onclick = () => modal.classList.add('show');
             span.onclick = () => modal.classList.remove('show');
             window.onclick = (event) => { if (event.target === modal) modal.classList.remove('show'); }
             window.onkeydown = (event) => { if (event.key === 'Escape' && modal.classList.contains('show')) modal.classList.remove('show'); }
         });

    </script>
</body>
</html>
